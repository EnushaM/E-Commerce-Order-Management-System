package com.cts.daoimpl;
/*These classes and the whole package is meant for accessing the database and dealing with CRUD operations
 *  within a table and it is taken as a separate class instead of dealing managements with class methods itself 
  so as not to interrupt the modules class with queries of SQL Database*/

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import com.cts.dao.ProductDao;
import com.cts.exceptions.ProductDeletionException;
import com.cts.exceptions.ProductInsertionException;
import com.cts.exceptions.ProductSelectionException;
import com.cts.exceptions.ProductUpdationException;
import com.cts.modules.Product;
import com.cts.util.DataBase;
import com.mysql.cj.protocol.Message;

public class ProductDaoImplementation implements ProductDao {
	private Connection con;
	private Product product;

	/*
	 * the connection is declared before itself defining the connection in a
	 * separate constructor in a separate database file to avoid multiple driver
	 * connections to the sql database and multiple nested try catch to be able to
	 * manage the module class under a single connection to database the connection
	 * defined in database file, is provided here as a class field being initialized
	 * through constructor parameter
	 */

	public ProductDaoImplementation(Connection con) {
		// TODO Auto-generated constructor stub
		// con = DataBase.getDatabaseConnection();
		this.con = con;
	}

	@Override
	public Product addProduct(String name, String description, double price, int quantity_in_stock)
			throws ProductInsertionException {
		// TODO Auto-generated method stub
		try {
			// SQL insert statement without product_id
			String insert = "INSERT INTO products(name, description, price, quantity_in_stock) VALUES(?,?,?,?)";
			/*
			 * ? used for dynamic update of values using prepared statement through
			 * parameters using prepared statement instead of create statement for higher
			 * parameters, dynamic query management Using prepared statement
			 */
			PreparedStatement psmt = con.prepareStatement(insert, Statement.RETURN_GENERATED_KEYS);
			/*
			 * Statement.RETURN_GENERATED_KEYS is to retrieve the auto-generated keys (such
			 * as primary keys) generated by the database during an INSERT operation.
			 */
			psmt.setString(1, name);
			psmt.setString(2, description);
			psmt.setDouble(3, price);
			psmt.setInt(4, quantity_in_stock);

			psmt.executeUpdate();

			ResultSet rs = psmt.getGeneratedKeys();
			// Retrieving the auto-generated product_id through key generator method

			if (rs.next()) {
				product = new Product(rs.getInt(1), name, description, price, quantity_in_stock);
			}
			rs.close();
			psmt.close();
			return product;
		} catch (SQLException e) {
			throw new ProductInsertionException("Error Adding Product" + e);
		}
	}

	public Product viewProductById(int product_id) throws ProductSelectionException {
		try {
			String select = "Select * from products where product_id=?";
			PreparedStatement psmt = con.prepareStatement(select);
			psmt.setInt(1, product_id);

			ResultSet rs = psmt.executeQuery();
			Product product = null;
			if (rs.next()) {
				product = new Product(rs.getInt("product_id"), rs.getString("name"), rs.getString("description"),
						rs.getDouble("price"), rs.getInt("quantity_in_stock"));
			}
			rs.close();
			psmt.close();
			return product;
		} catch (SQLException e) {
			throw new ProductSelectionException("Error Viewing Products" + e);

		}
	}

	@Override
	public List<Product> viewProductbyName(String name) throws ProductSelectionException {
		List<Product> productsList = new ArrayList<>();
		try {
			String select = "select * from products where name = ?";
			PreparedStatement psmt = con.prepareStatement(select, ResultSet.TYPE_SCROLL_INSENSITIVE,
					ResultSet.CONCUR_UPDATABLE);
			psmt.setString(1, name);

			ResultSet rs = psmt.executeQuery();
			if (rs.next()) {
				rs.beforeFirst();

				while (rs.next()) {
					product = new Product(rs.getInt(1), name, rs.getString(3), rs.getDouble(4), rs.getInt(5));
					productsList.add(product);
				}
			}
			rs.close();
			psmt.close();
			return productsList;

		} catch (SQLException e) {
			throw new ProductSelectionException("Error Viewing Products" + e);

		}
	}

	@Override
	public Product existProduct(int product_id) throws ProductSelectionException {
		try {
			String exist_product = "select * from products where product_id=?";
			PreparedStatement psmt = con.prepareStatement(exist_product);
			psmt.setInt(1, product_id);

			ResultSet rs = psmt.executeQuery();
			if (rs.next()) {
				product = new Product(product_id, rs.getString(2), rs.getString(3), rs.getInt(4), rs.getInt(5));
			}
			psmt.close();
			rs.close();
			return product;
		} catch (SQLException e) {
			throw new ProductSelectionException("Error Viewing Products" + e);

		}
	}

	@Override
	public List<Product> viewAllProducts() throws ProductSelectionException {
		// TODO Auto-generated method stub
		List<Product> productsList = new ArrayList<>();
		try {
			String selectAllProducts = "select*from products";
			PreparedStatement psmt_selectAllProducts = con.prepareStatement(selectAllProducts,
					ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			/*
			 * ResultSet.TYPE_SCROLL_INSENSITIVE ResultSet.CONCUR_READ_ONLY
			 * =>ResultSet.CONCUR_READ_ONLY specify that the ResultSet is read-only, since
			 * we move from back and forth of the resultset, order may get changed both used
			 * because we are moving to next row from first row and will also move backward
			 * again
			 */
			ResultSet rs_psmt_selectAllProducts = psmt_selectAllProducts.executeQuery();
			if (rs_psmt_selectAllProducts.next()) {
				// Moving the cursor back to the beginning of the ResultSet using
				// rs.beforeFirst()
				rs_psmt_selectAllProducts.beforeFirst();
				while (rs_psmt_selectAllProducts.next()) {
					Product product = new Product(rs_psmt_selectAllProducts.getInt(1),
							rs_psmt_selectAllProducts.getString(2), rs_psmt_selectAllProducts.getString(3),
							rs_psmt_selectAllProducts.getInt(4), rs_psmt_selectAllProducts.getInt(5));
					productsList.add(product);
				}
			}
			rs_psmt_selectAllProducts.close();
			psmt_selectAllProducts.close();
			return productsList;

		} catch (SQLException e) {
			throw new ProductSelectionException("Error Viewing Products" + e);
		}
	}

	@Override
	public boolean deleteProduct(int product_id) throws ProductDeletionException {
		// TODO Auto-generated method stub
		try {
			String delete = "delete from products where product_id=?";

			PreparedStatement psmt = con.prepareStatement(delete);
			psmt.setInt(1, product_id);
			int rowsInserted = psmt.executeUpdate();
			psmt.close();

			if (rowsInserted > 0) {
				return true;
			}
		} catch (SQLException e) {
			throw new ProductDeletionException("Error Deleting Products" + e);

		}
		return false;
	}

	public int updateProduct(int product_id, String existingName, String existingDescription,
			int existingQuantityInStock, double existingPrice, String name, String description, int quantityInStock,
			double price) throws ProductUpdationException {
		try {
			StringBuilder updateQuery = new StringBuilder("UPDATE products SET ");
			if (!name.equals(existingName))
				updateQuery.append("name=?, ");
			if (!description.equals(existingDescription))
				updateQuery.append("description=?, ");
			if (quantityInStock != existingQuantityInStock)
				updateQuery.append("quantity_in_stock=?, ");
			if (price != existingPrice)
				updateQuery.append("price=?, ");

			updateQuery.setLength(updateQuery.length() - 2);
			// Remove trailing comma and space since we appended a ? and space in the update
			// query

			updateQuery.append(" WHERE product_id=?");

			PreparedStatement update_psmt = con.prepareStatement(updateQuery.toString());

			int parameterIndex = 1;
			if (!name.equals(existingName))
				update_psmt.setString(parameterIndex++, name);
			if (!description.equals(existingDescription))
				update_psmt.setString(parameterIndex++, description);
			if (quantityInStock != existingQuantityInStock)
				update_psmt.setInt(parameterIndex++, quantityInStock);
			if (price != existingPrice)
				update_psmt.setDouble(parameterIndex++, price);

			update_psmt.setInt(parameterIndex, product_id);

			int rowsUpdated = update_psmt.executeUpdate();

			update_psmt.close();
			return rowsUpdated;
		} catch (SQLException e) {
			throw new ProductUpdationException("Error Updating Products" + e);
		}
	}
}
