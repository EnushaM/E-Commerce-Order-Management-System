package com.cts.daoimpl;
/*These classes and the whole package is meant for accessing the database and dealing with CRUD operations
 *  within a table and it is taken as a separate class instead of dealing managements with class methods itself 
  so as not to interrupt the modules class with queries of SQL Database*/

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.cts.dao.OrderDao;
import com.cts.exceptions.OrderDeletionException;
import com.cts.exceptions.OrderInsertionException;
import com.cts.exceptions.OrderItemsDeletionException;
import com.cts.exceptions.OrderItemsSelectionException;
import com.cts.exceptions.OrderItemsUpdationException;
import com.cts.exceptions.OrderNotFoundException;
import com.cts.exceptions.OrderSelectionException;
import com.cts.exceptions.OrderUpdationException;
import com.cts.exceptions.UpdateStockException;
import com.cts.modules.Order;
import com.cts.modules.OrderItem;
import com.cts.modules.OrderItemCart;
import com.cts.modules.Product;
import com.cts.util.DataBase;

public class OrderDaoImplementation implements OrderDao {
	private Connection con;
	private Order order;
	private Product product;

	/*
	 * the connection is declared before itself defining the connection in a
	 * separate constructor in a separate database file to avoid multiple driver
	 * connections to the sql database and multiple nested try catch to be able to
	 * manage the module class under a single connection to database the connection
	 * defined in database file, is provided here as a class field being initialized
	 * through constructor parameter
	 */

	public OrderDaoImplementation(Connection con) {
		// TODO Auto-generated constructor stub
		this.con=con;

	}

	@Override
	public Order addOrder(int customer_id, List<OrderItem> orderItemsList, double total) throws OrderInsertionException {
		// TODO Auto-generated method stub
		try {
			// SQL insert statement without order_id

			String insertOrder = "insert into orders(customer_id, order_date, total_amount,status) values (?,now(),?,'pending')";

			PreparedStatement insertOrder_psmt = con.prepareStatement(insertOrder, Statement.RETURN_GENERATED_KEYS);
			/*
			 * Statement.RETURN_GENERATED_KEYS is to retrieve the auto-generated keys (such
			 * as primary keys) generated by the database during an insert operation.
			 */
			insertOrder_psmt.setInt(1, customer_id);

			insertOrder_psmt.setDouble(2, total);
			;
			insertOrder_psmt.executeUpdate();

			ResultSet rs_insertOrder_psmt = insertOrder_psmt.getGeneratedKeys();
			// Retrieving the auto-generated order_id through key generator method
			if (rs_insertOrder_psmt.next()) {
				order=new Order(
						rs_insertOrder_psmt.getInt(1),customer_id,Timestamp.valueOf(LocalDateTime.now()),total,"confirmed"
						);
			}
			rs_insertOrder_psmt.close();
			insertOrder_psmt.close();
			return order;
		} catch (SQLException e) {
			throw new OrderInsertionException("Error Adding Order");
		}
	}

	@Override
	public boolean insertOrderItemsFromList__UpdateQuantity_in_stock(int order_id, List<OrderItem> orderItemsList) throws UpdateStockException {
		try {
			String updateQuantity_in_stock = "update products set quantity_in_stock = quantity_in_stock-? where product_id=?";

			String insertOrderItem = "insert into order_items (order_id, product_id, quantity, price) values(?,?,?,?)";

			PreparedStatement updateQuantity_in_stock_psmt = con.prepareStatement(updateQuantity_in_stock);

			PreparedStatement insertOrderItems_psmt = con.prepareStatement(insertOrderItem,
					Statement.RETURN_GENERATED_KEYS);

			for (OrderItem orderItem : orderItemsList) {
				insertOrderItems_psmt.setInt(1, order_id);
				insertOrderItems_psmt.setInt(2, orderItem.getProduct_id());
				insertOrderItems_psmt.setInt(3, orderItem.getQuantity());
				insertOrderItems_psmt.setDouble(4, orderItem.getPrice());
				insertOrderItems_psmt.executeUpdate();
				// ResultSet rs_insertOrderItems_psmt =
				// insertOrderItems_psmt.getGeneratedKeys();
				// not getting order_id from result set since it is not required here, but the
				// primary key order_id gets generated
				updateQuantity_in_stock_psmt.setInt(1, orderItem.getQuantity());
				updateQuantity_in_stock_psmt.setInt(2, orderItem.getProduct_id());
				updateQuantity_in_stock_psmt.executeUpdate();
			}
			return true;
		} catch (SQLException e) {
			throw new UpdateStockException("Error Updating Stock");
			
		}
	}

	/*
	 * function to update order status and boolean return value is used for classes
	 * where successful query execution (rows being affected) must be checked
	 */
	@Override
	public boolean updateOrderStatusforOrderId(int order_id, String message) throws OrderUpdationException {
		try {
			String updateOrderStatus = "update orders set status=? where order_id=?";
			PreparedStatement updateOrderStatus_psmt = con.prepareStatement(updateOrderStatus);
			updateOrderStatus_psmt.setString(1, message);
			updateOrderStatus_psmt.setInt(2, order_id);
			updateOrderStatus_psmt.executeUpdate();
			return true;
		} catch (SQLException e) {
			throw new OrderUpdationException("Error Updating Order");

		}
	}

	@Override
	public List<OrderItemCart> viewOrderitems(int order_id) throws OrderItemsSelectionException {
		List<OrderItemCart> orderItemsList = new ArrayList<>();
		try {
			String selectOrderItem = "select oi.order_item_id, oi.order_id, p.name, oi.price, oi.quantity, "
					+ "oi.quantity * oi.price AS total_price " + "from order_items oi "
					+ "JOIN orders p ON oi.order_id = p.order_id " + "where oi.order_id = ?";

			PreparedStatement selectOrderItem_psmt = con.prepareStatement(selectOrderItem,ResultSet.TYPE_SCROLL_INSENSITIVE,
					ResultSet.CONCUR_UPDATABLE);
			selectOrderItem_psmt.setInt(1, order_id);
			ResultSet rs_selectOrderItem_psmt = selectOrderItem_psmt.executeQuery();

			if (rs_selectOrderItem_psmt.next()) {
				rs_selectOrderItem_psmt.beforeFirst();
				while (rs_selectOrderItem_psmt.next()) {
					
					OrderItemCart orderItemCart = new OrderItemCart(
							rs_selectOrderItem_psmt.getInt(1),
							order_id,
							rs_selectOrderItem_psmt.getInt(3),
							rs_selectOrderItem_psmt.getString(4),
							rs_selectOrderItem_psmt.getDouble(5),
							rs_selectOrderItem_psmt.getInt(6),
							rs_selectOrderItem_psmt.getDouble(7)
							);
					orderItemsList.add(orderItemCart);
				}
			}
		} catch (SQLException e) {
			throw new OrderItemsSelectionException("Error Retrieving Order Items");

		}
		return orderItemsList;

	}

	@Override
	public Order viewOrderById(int order_id) throws OrderNotFoundException, OrderSelectionException {
		try {
			String select = "Select * from orders where order_id=?";
			PreparedStatement psmt = con.prepareStatement(select);
			psmt.setInt(1, order_id);

			ResultSet rs = psmt.executeQuery();
			Order order = null;
			if (rs.next()) {
				order = new Order(rs.getInt("order_id"), rs.getInt("customer_id"), rs.getTimestamp("order_date"),
						rs.getDouble("total_amount"), rs.getString("status"));
			}
			else {
				throw new OrderNotFoundException("Order not Found");
			}
			rs.close();
			psmt.close();
			return order;
		} catch (SQLException e) {
			throw new OrderSelectionException("Error Retrieving Orders");

		}
	}

	@Override
	public Order existOrder(int order_id) throws OrderNotFoundException, OrderSelectionException {
		try {
			String exist_order = "select * from orders where order_id=?";
			PreparedStatement psmt = con.prepareStatement(exist_order);
			psmt.setInt(1, order_id);

			ResultSet rs = psmt.executeQuery();
			order = null;
			if (rs.next()) {
				order.setCustomer_id(rs.getInt("customer_id"));
				order.setOrder_date(rs.getTimestamp("order_date"));
				order.setOrder_id(rs.getInt("order_id"));
				order.setStatus(rs.getString("status"));
				order.setTotal_amount(rs.getDouble("total_amount"));
			}
			else {
				throw new OrderNotFoundException("Order not Found");
			}
			psmt.close();
			rs.close();
			return order;
		} catch (SQLException e) {
			throw new OrderSelectionException("Error Retrieving Orders");
		}
	}

	@Override
	public List<Order> viewAllProducts() throws OrderSelectionException {
		// TODO Auto-generated method stub
		List<Order> ordersList = new ArrayList<>();
		try {
			String selectAllOrders = "select*from orders";
			PreparedStatement psmt_selectAllOrders = con.prepareStatement(selectAllOrders,
					ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			/*
			 * ResultSet.TYPE_SCROLL_INSENSITIVE ResultSet.CONCUR_READ_ONLY
			 * =>ResultSet.CONCUR_READ_ONLY specify that the ResultSet is read-only, since
			 * we move from back and forth of the resultset, order may get changed both used
			 * because we are moving to next row from first row and will also move backward
			 * again
			 */
			ResultSet rs_psmt_selectAllOrders = psmt_selectAllOrders.executeQuery();
			if (rs_psmt_selectAllOrders.next()) {

				while (rs_psmt_selectAllOrders.next()) {
					product = new Product(rs_psmt_selectAllOrders.getInt(1),
							rs_psmt_selectAllOrders.getString(2), rs_psmt_selectAllOrders.getString(3),
							rs_psmt_selectAllOrders.getInt(4), rs_psmt_selectAllOrders.getInt(5));
					ordersList.add(order);
				}
			}
			rs_psmt_selectAllOrders.close();
			psmt_selectAllOrders.close();
			return ordersList;

		} catch (SQLException e) {
			throw new OrderSelectionException("Error Retrieving Orders");

		}
	}
	@Override
	public Map<Integer, Integer> selectOrderItem(int order_id) throws OrderSelectionException {
		try {
			/*
			 * moving to the exact update function, if none of the above conditions satisfy
			 */
			String selectOrderItem = "select product_id, quantity from order_items where order_id = ?";
			/*
			 * selecting only the product_id, quantity since those are the only values that
			 * be updated product id is used, since selecting product name retrieves many
			 * rows with similar name which can be figured out in enhanced system by adding
			 * a unique not null brand name, and retrieving, prompting user input for brand
			 * and getting the corresponding product id for updation
			 */
			Map<Integer, Integer> existingItems = new HashMap<>();
			/*
			 * storing the product id and quantity for easier update through a unmutable key
			 * and mutable value pair. product id can not changed and only be removed by
			 * removing item through setting quantity to 0
			 */
			PreparedStatement selectOrderItem_psmt = con.prepareStatement(selectOrderItem);
			selectOrderItem_psmt.setInt(1, order_id);

			ResultSet rs_selectOrderItem = selectOrderItem_psmt.executeQuery();

			while (rs_selectOrderItem.next()) {
				existingItems.put(rs_selectOrderItem.getInt("product_id"), rs_selectOrderItem.getInt("quantity"));
			}
			return existingItems;
		} catch (SQLException e) {
			throw new OrderSelectionException("Error Retrieving Orders");

		}

	}

	@Override
	public boolean deleteOrderItem(int order_id, int product_id) throws OrderItemsDeletionException {
		try {
			String deleteOrderItem = "delete from order_items where order_id = ? and product_id = ?";
			PreparedStatement deleteOrderItem_psmt = con.prepareStatement(deleteOrderItem);
			deleteOrderItem_psmt.setInt(1, order_id);
			deleteOrderItem_psmt.setInt(2, product_id);
			deleteOrderItem_psmt.executeUpdate();
			return true;
		} catch (SQLException e) {
			throw new OrderItemsDeletionException("Error Deleting Order Items");
		}

	}

	/*
	 * function to update product quantity in stock
	 */

	@Override
	public List<Order> viewAllOrders() throws OrderSelectionException {
		// TODO Auto-generated method stub
		List<Order> ordersList = new ArrayList<>();
		try {
			String selectAllOrders = "select*from orders";
			PreparedStatement psmt_selectAllOrders = con.prepareStatement(selectAllOrders,
					ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			/*
			 * ResultSet.TYPE_SCROLL_INSENSITIVE ResultSet.CONCUR_READ_ONLY
			 * =>ResultSet.CONCUR_READ_ONLY specify that the ResultSet is read-only, since
			 * we move from back and forth of the resultset, order may get changed both used
			 * because we are moving to next row from first row and will also move backward
			 * again
			 */
			ResultSet rs_psmt_selectAllOrders = psmt_selectAllOrders.executeQuery();
			if (rs_psmt_selectAllOrders.next()) {

				while (rs_psmt_selectAllOrders.next()) {
					
					Order order = new Order(
							rs_psmt_selectAllOrders.getInt("order_id"), 
							rs_psmt_selectAllOrders.getInt("customer_id"),
							rs_psmt_selectAllOrders.getTimestamp("order_date"),
							rs_psmt_selectAllOrders.getDouble("total_amount"),
							rs_psmt_selectAllOrders.getString("status")
							);
							
					ordersList.add(order);
				}
			}
			rs_psmt_selectAllOrders.close();
			psmt_selectAllOrders.close();
			return ordersList;

		} catch (SQLException e) {
			throw new OrderSelectionException("Error Retrieving Orders");
		}
	}

	@Override
	public boolean deleteOrder(int order_id) throws OrderDeletionException {
		// TODO Auto-generated method stub
		try {
			String delete = "delete from orders where order_id=?";

			PreparedStatement psmt = con.prepareStatement(delete);
			psmt.setInt(1, order_id);
			int rowsInserted = psmt.executeUpdate();
			psmt.close();

			if (rowsInserted > 0) {
				return true;
			}
		} catch (SQLException e) {
			throw new OrderDeletionException("Error Deleting Order");
		}
		return false;
	}

	@Override
	public Product existProductInCart(int order_id, int product_id) throws OrderSelectionException {
		try {
			String exist_product = "select * from order_items where order_id=? and product_id=?";
			PreparedStatement psmt = con.prepareStatement(exist_product);
			psmt.setInt(1, order_id);
			psmt.setInt(2, product_id);

			ResultSet rs = psmt.executeQuery();
			product = null;
			if (rs.next()) {
				product.setName(null);
				product.setDescription(null);
				product.setPrice(rs.getDouble("price"));
				product.setQuantity_in_stock(rs.getInt("quantity"));
			}
			psmt.close();
			rs.close();
			return product;
		} catch (SQLException e) {
			throw new OrderSelectionException("Error Retrieving Orders");
					
		}
	}

	/*
	 * function to update product quantity in stock
	 */
	@Override
	public void updateProductStock(int product_id, int quantityToBeAdded) throws UpdateStockException {
		try {
			String updateStock = "update products set quantity_in_stock = quantity_in_stock + ? where product_id = ?";
			PreparedStatement updateStock_psmt = con.prepareStatement(updateStock);
			updateStock_psmt.setInt(1, quantityToBeAdded);
			updateStock_psmt.setInt(2, product_id);
			updateStock_psmt.executeUpdate();
		} catch (SQLException e) {
			throw new UpdateStockException("Error Updating Stock");

		}

	}

	@Override
	public void updateOrderItem(int order_id, int product_id, int quantity, double price) throws OrderItemsUpdationException {
		try {
			String updateOrderItem = "update order_items set quantity = ?, price = ? where order_id = ? and product_id = ?";
			PreparedStatement updateOrderItem_psmt = con.prepareStatement(updateOrderItem);
			updateOrderItem_psmt.setInt(1, quantity);
			updateOrderItem_psmt.setDouble(2, price);
			updateOrderItem_psmt.setInt(3, order_id);
			updateOrderItem_psmt.setInt(4, product_id);
			updateOrderItem_psmt.executeUpdate();
			/*
			 * updating the price too with the same existing price for smoother update
			 * process but the user is not prompted for price input, since it isn't
			 * decidable by the customer
			 */
		} catch (SQLException e) {
			// TODO: handle exception
			throw new OrderItemsUpdationException("Error Updating Order Items");
		}
	}

	@Override
	public double calculateNewTotalAmount(int order_id) throws OrderSelectionException {
		double totalAmount = 0;

		try {
			String selectOrderItem = "select price, quantity from order_items where order_id = ?";
			PreparedStatement selectOrderItem_psmt = con.prepareStatement(selectOrderItem);
			selectOrderItem_psmt.setInt(1, order_id);
			ResultSet rs_selectOrderItem = selectOrderItem_psmt.executeQuery();
			while (rs_selectOrderItem.next()) {
				totalAmount += rs_selectOrderItem.getDouble("price") * rs_selectOrderItem.getInt("quantity");
			}

		} catch (SQLException e) {
			throw new OrderSelectionException("Error Retrieving Orders");

		}
		return totalAmount;
	}

	@Override

	public boolean updateOrderTotal(int order_id, double newTotalAmount) throws OrderUpdationException {
		try {
			String updateOrderTotal = "update orders set total_amount = ? where order_id = ?";
			PreparedStatement updateOrderTotal_psmt = con.prepareStatement(updateOrderTotal);
			updateOrderTotal_psmt.setDouble(1, newTotalAmount);
			updateOrderTotal_psmt.setInt(2, order_id);
			int rowsAffected = updateOrderTotal_psmt.executeUpdate();
			if (rowsAffected > 0) {
				return true;
			}
		} catch (SQLException e) {
			// TODO: handle exception
			throw new OrderUpdationException("Error Updating Order");

		}
		return false;
	}

	@Override
	public int updateOrder(int order_id, String existingName, String existingDescription, int existingQuantityInStock,
			double existingPrice, String name, String description, int quantityInStock, double price) throws OrderUpdationException {
		try {
			StringBuilder updateQuery = new StringBuilder("UPDATE orders SET ");
			if (!name.equals(existingName))
				updateQuery.append("name=?, ");
			if (!description.equals(existingDescription))
				updateQuery.append("description=?, ");
			if (quantityInStock != existingQuantityInStock)
				updateQuery.append("quantity_in_stock=?, ");
			if (price != existingPrice)
				updateQuery.append("price=?, ");

			updateQuery.setLength(updateQuery.length() - 2);
			// Remove trailing comma and space since we appended a ? and space in the update
			// query

			updateQuery.append(" WHERE order_id=?");

			PreparedStatement update_psmt = con.prepareStatement(updateQuery.toString());

			int parameterIndex = 1;
			if (!name.equals(existingName))
				update_psmt.setString(parameterIndex++, name);
			if (!description.equals(existingDescription))
				update_psmt.setString(parameterIndex++, description);
			if (quantityInStock != existingQuantityInStock)
				update_psmt.setInt(parameterIndex++, quantityInStock);
			if (price != existingPrice)
				update_psmt.setDouble(parameterIndex++, price);

			update_psmt.setInt(parameterIndex, order_id);

			int rowsUpdated = update_psmt.executeUpdate();

			update_psmt.close();
			return rowsUpdated;
		} catch (SQLException e) {
			throw new OrderUpdationException("Error Updating Order");

		}
	}

	@Override
	public Map<String, Object> viewOrder(int order_id) throws OrderNotFoundException, OrderSelectionException {
		Map<String, Object> orderDetailsMap = new HashMap<>();
		try {
			String selectOrder = "select o.order_id, o.order_date, o.total_amount,"
					+ " o.status, c.customer_id, c.name, c.email, c.phone, c.address"
					+ " from orders o join customers c on o.customer_id = c.customer_id where o.order_id = ?";

			PreparedStatement selectOrder_psmt = con.prepareStatement(selectOrder);

			selectOrder_psmt.setInt(1, order_id);
			ResultSet rs_selectOrder = selectOrder_psmt.executeQuery();
			String keys[] = { "order_id", "order_date", "total_amount", "status", "customer_id", "name", "phone",
					"email", "address" };

			if (rs_selectOrder.next()) {
				Object values[] = { rs_selectOrder.getInt("order_id"), rs_selectOrder.getTimestamp("order_date"),
						rs_selectOrder.getDouble("total_amount"), rs_selectOrder.getString("status"),
						rs_selectOrder.getInt("customer_id"), rs_selectOrder.getString("name"),
						rs_selectOrder.getString("phone"), rs_selectOrder.getString("email"),
						rs_selectOrder.getString("address") };
				for (int i = 0; i < keys.length; i++) {
					orderDetailsMap.put(keys[i], values[i]);
				}
			}
			else {
				throw new OrderNotFoundException("Order not Found");
			}
			rs_selectOrder.close();
			selectOrder_psmt.close();
			return orderDetailsMap;

		} catch (SQLException e) {
			throw new OrderSelectionException("Error Retrieving Orders");

		}
	}
@Override
	public boolean cancelOrder(int order_id) throws OrderUpdationException, UpdateStockException {
		try {
			String selectOrderItems = "select product_id, quantity from order_items where order_id=?";
			PreparedStatement selectOrderItems_psmt = con.prepareStatement(selectOrderItems);
			selectOrderItems_psmt.setInt(1, order_id);
			ResultSet rs_selectOrderItems_psmt = selectOrderItems_psmt.executeQuery();
			/*
			 * selecting the quantity added to be increased to existing quantity in stock
			 * since, the order is going be deleted
			 */
			
			while (rs_selectOrderItems_psmt.next()) {
				int product_id = rs_selectOrderItems_psmt.getInt("product_id");
				int quantity = rs_selectOrderItems_psmt.getInt("quantity");
				/*
				 * when an order is cancelled, each order item quantity is increased to the
				 * existing quantity in stock
				 */
				updateProductStock(product_id, quantity);
			}
			return true;
		} catch (SQLException e) {
			throw new OrderUpdationException("Error Updating Order");

		}
	}
	/*
	 * when the order is cancelled, its status is labelled as cancelled, but the
	 * order row in table is not deleted for account management of admin under
	 * "cancelled orders", but can be delted post a long time through Thread.sleep()
	 * functionality for further enhanced system but the order items row need not be
	 * deleted since it will be required for analysis forcancelled order items nor
	 * flagged by adding new status column which will be make the table look dirty
	 * as there will be multiple individual rows with same order id
	 * 
	 */
}
