package com.cts.daoimpl;
/*These classes and the whole package is meant for accessing the database and dealing with CRUD operations
 *  within a table and it is taken as a separate class instead of dealing managements with class methods itself 
  so as not to interrupt the modules class with queries of SQL Database*/

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import com.cts.dao.CustomerDao;
import com.cts.exceptions.CustomerDeletionException;
import com.cts.exceptions.CustomerInsertionException;
import com.cts.exceptions.CustomerNotFoundException;
import com.cts.exceptions.CustomerSelectionException;
import com.cts.exceptions.CustomerUpdationException;
import com.cts.modules.Customer;
import com.cts.modules.Product;
import com.cts.util.DataBase;

public class CustomerDaoImplementation implements CustomerDao {
	private Connection con;
	private Customer customer;

	/*
	 * the connection is declared before itself defining the connection in a
	 * separate constructor in a separate database file to avoid multiple driver
	 * connections to the sql database and multiple nested try catch to be able to
	 * manage the module class under a single connection to database the connection
	 * defined in database file, is provided here as a class field being initialized
	 * through constructor parameter
	 */
	public CustomerDaoImplementation(Connection con) {
		// TODO Auto-generated constructor stub
		//con = DataBase.getDatabaseConnection();
		this.con=con;
	}

	@Override
	public Customer addCustomer(String name, String email, long phone, String address) throws CustomerInsertionException {
		// TODO Auto-generated method stub
		try {
			// SQL insert statement without customer_id
			String insert = "insert into customers (name, email, phone, address) values (?, ?, ?, ?)";
			/*
			 * ? used for dynamic update of values using prepared statement through
			 * parameters using prepared statement instead of create statement for higher
			 * parameters, dynamic query management Using prepared statement
			 */
			PreparedStatement psmt = con.prepareStatement(insert, Statement.RETURN_GENERATED_KEYS);
			/*
			 * Statement.RETURN_GENERATED_KEYS is to retrieve the auto-generated keys (such
			 * as primary keys) generated by the database during an INSERT operation.
			 */
			psmt.setString(1, name);
			psmt.setString(2, email);
			psmt.setLong(3, phone);
			psmt.setString(4, address);

			psmt.executeUpdate();

			ResultSet rs = psmt.getGeneratedKeys();
			// Retrieving the auto-generated customer_id through key generator method
			if (rs.next()) {
				customer=new Customer(
						rs.getInt(1),name, email,phone,address
						);
			}
			rs.close();
			psmt.close();
			return customer;
		} catch (SQLException e) {
			throw new CustomerInsertionException("Error Adding Customer");
		}
	}

	@Override
	public Customer viewCustomerById(int customer_id) throws CustomerSelectionException, CustomerNotFoundException {
		try {
			String select = "Select * from customers where customer_id=?";
			PreparedStatement psmt = con.prepareStatement(select);
			psmt.setInt(1, customer_id);

			ResultSet rs = psmt.executeQuery();
			if (rs.next()) {
				customer = new Customer(rs.getInt(1), rs.getString(2), rs.getString(3), rs.getLong(4),
						rs.getString(5));
			}
			else {
				throw new CustomerNotFoundException("No Customers Found");
	
			}
			rs.close();
			psmt.close();
			return customer;
		} catch (SQLException e) {
			throw new CustomerSelectionException("Error viewing Customer");

		}	}

	@Override
	public List<Customer> viewCustomerbyName(String name) throws CustomerSelectionException, CustomerNotFoundException {
		List<Customer> customersList = new ArrayList<>();
		try {
			String select = "select * from customers where name = ?";
			PreparedStatement psmt = con.prepareStatement(select,ResultSet.TYPE_SCROLL_INSENSITIVE,
					ResultSet.CONCUR_UPDATABLE);
			psmt.setString(1, name);

			ResultSet rs = psmt.executeQuery();
			if (rs.next()) {
				rs.beforeFirst();

				while (rs.next()) {
					customer = new Customer(
							rs.getInt(1), 
							name, 
							rs.getString(3), 
							rs.getLong(4), 
							rs.getString(5)
							);
					customersList.add(customer);
				}
			}
			else {
				throw new CustomerNotFoundException("No Customers Found");
			}
			rs.close();
			psmt.close();
			return customersList;

		} catch (SQLException e) {
			
			throw new CustomerSelectionException("Error Retrieving Customers");
		}
	}

	@Override
	public Customer existCustomer(int customer_id) throws CustomerSelectionException {
		try {
			String exist_customer = "select * from customers where customer_id=?";
			PreparedStatement psmt = con.prepareStatement(exist_customer);
			psmt.setInt(1, customer_id);

			ResultSet rs = psmt.executeQuery();
			if (rs.next()) {
				customer =new Customer(customer_id,rs.getString(2),rs.getString(3),rs.getLong(4),rs.getString(5));
			} 
			rs.close();
			psmt.close();
			return customer;

		} catch (SQLException e)			{
			throw new CustomerSelectionException("Error Retrieving Customers");
			
		}
	}

	@Override
	public List<Customer> viewAllCustomers() throws CustomerSelectionException {
		// TODO Auto-generated method stub
		List<Customer> customersList = new ArrayList<>();
		try {
			String selectAllCustomers = "select*from customers";
			PreparedStatement psmt_selectAllCustomers = con.prepareStatement(selectAllCustomers,
					ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			/*
			 * ResultSet.TYPE_SCROLL_INSENSITIVE ResultSet.CONCUR_READ_ONLY
			 * =>ResultSet.CONCUR_READ_ONLY specify that the ResultSet is read-only, since
			 * we move from back and forth of the resultset, order may get changed both used
			 * because we are moving to next row from first row and will also move backward
			 * again
			 */
			ResultSet rs_psmt_selectAllCustomers = psmt_selectAllCustomers.executeQuery();
			if (rs_psmt_selectAllCustomers.next()) {
				while (rs_psmt_selectAllCustomers.next()) {
					Customer customer = new Customer(rs_psmt_selectAllCustomers.getInt(1),
							rs_psmt_selectAllCustomers.getString(2), rs_psmt_selectAllCustomers.getString(3),
							rs_psmt_selectAllCustomers.getLong(4), rs_psmt_selectAllCustomers.getString(5));
					customersList.add(customer);
				}
			}
			rs_psmt_selectAllCustomers.close();
			psmt_selectAllCustomers.close();
			return customersList;

		} catch (SQLException e) {
			throw new CustomerSelectionException("Error Retrieving Customers");

			
		}
	}

	@Override
	public boolean deleteCustomer(int customer_id) throws CustomerDeletionException {
		// TODO Auto-generated method stub
		try {
			String delete = "delete from customers where customer_id=?";

			PreparedStatement psmt = con.prepareStatement(delete);
			psmt.setInt(1, customer_id);
			int rowsInserted = psmt.executeUpdate();
			psmt.close();

			if (rowsInserted > 0) {
				return true;
			}
		} catch (SQLException e) {
			throw new CustomerDeletionException("Error Deleting Customers");
			
		}
		return false;
	}

	@Override
	public int updateCustomer(int customer_id, String existingName, long existingPhone, String existingEmail,
			String existingAddress, String name, long phone, String email, String address) throws CustomerUpdationException {
		// TODO Auto-generated method stub
		try {
			StringBuilder updateQuery = new StringBuilder("UPDATE customers SET ");
			if (!name.equals(existingName))
				updateQuery.append("name=?, ");
			if (phone!=existingPhone)
				updateQuery.append("phone=?, ");
			if (!email.equals(existingEmail))
				updateQuery.append("email=?, ");
			if (!address.equals(existingAddress))
				updateQuery.append("address=?, ");

			updateQuery.setLength(updateQuery.length() - 2);
			// Remove trailing comma and space since we appended a ? and space in the update
			// query

			updateQuery.append(" WHERE customer_id=?");

			PreparedStatement update_psmt = con.prepareStatement(updateQuery.toString());

			int parameterIndex = 1;
			if (!name.equals(existingName))
				update_psmt.setString(parameterIndex++, name);
			if (phone!=existingPhone)
				update_psmt.setLong(parameterIndex, parameterIndex);
			if (!email.equals(existingEmail))
				updateQuery.append("email=?, ");
			if (!address.equals(existingAddress))
				updateQuery.append("address=?, ");
			update_psmt.setInt(parameterIndex, customer_id);

			int rowsUpdated = update_psmt.executeUpdate();

			update_psmt.close();
			return rowsUpdated;
		} catch (SQLException e) {
			throw new CustomerUpdationException("Error Updating Customers");
		}
	}
}
